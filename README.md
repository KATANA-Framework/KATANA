# KATANA Framework

KATANA — серверный фреймворк на C++ для разработки высоконагруженных API и систем с жесткими требованиями к хвостовым задержкам (p95/p99/p999), контролируемым использованием ресурсов и предсказуемым поведением под нагрузкой.

Основная цель — устранение разрыва между:
1) Стеком, ориентированным на скорость разработки, но нестабильным под нагрузкой (Python/Node).
2) Высокопроизводительными, но сложными в сопровождении системами на raw C++/Rust/Go.

Фреймворк обеспечивает предсказуемость выполнения, контролируемое управление памятью и стабильные задержки, при этом не усложняя model/domain логику.

---

## Проблемы, которые решает KATANA

- Неустойчивость latency при росте нагрузки за счет глобальных пулов, аллокаторов, GC и межпоточных гонок.
- N+1 и непредсказуемые запросы в ORM.
- Ручное дублирование типов, DTO, сериализации и валидации.
- Несоответствие документации и реального API.
- Неуправляемое кэширование и непредсказуемый rate limiting.
- Сложность анализа узких мест и отсутствия наблюдаемости.

---

## Архитектурная модель

### Reactor-per-core
Каждое ядро CPU получает свой независимый event loop, свой пул соединений с БД, свой кэш и собственное пространство памяти.  
Запрос полностью обрабатывается внутри одного реактора.

- Нет глобального состояния.
- Нет межпоточных локаций.
- Нет очередей на общий пул БД.
- Полное отсутствие гонок на уровне модели исполнения.

### Управление памятью
Каждый запрос выполняется внутри **arena-per-request** (монотонный аллокатор).  
Память освобождается одной операцией по завершению запроса.

Доступные режимы:
- `arena` (по умолчанию)
- `std::pmr` с выбором `memory_resource`
- стандартный `new/delete` (через флаг `--no-arena`)

Нет принудительной замены стандартных контейнеров.  
Типы DTO и структуры используют `std::pmr::*` и `std::string_view`.

### I/O
- epoll + vectored I/O (`readv/writev`)
- HTTP/1.1 базовый сервер
- HTTP/2 и HTTP/3/QUIC в производственных профилях
- sendfile/kTLS/io_uring используются при доступности ядра

---

## Типизация API и кодогенерация

OpenAPI является единственным источником истины.

Генератор создает:
- маршрутизацию (без строковых сравнений в runtime)
- DTO с строго типизированными полями
- валидаторы входных данных
- сериализацию/десериализацию
- статические таблицы маршрутов

Ошибки несоответствия API фиксируются **на этапе компиляции**, а не во время исполнения.

### Расширения OpenAPI (`x-katana-*`)
Фреймворк не модифицирует стандарт.  
Расширения позволяют управлять:
- стратегией аллокации
- выбором сериализатора (zero-copy / dom)
- кэшированием (TTL, stale-while-revalidate)
- rate limiting
- политикой консистентности

---

## Работа с базой данных

ORM не используется.

SQL-запросы описываются в `.sql` файлах и служат входом для генератора, который создает:
- модели данных
- репозитории
- транзакционные обертки
- bulk-операции
- типобезопасные фильтры и сортировки

Особенности:
- libpq binary protocol + prepared statements
- пул соединений организован **per-core**
- никакой ленивой загрузки
- явный prefetch вместо N+1

---

## Кэш и Redis

Кэширование, idempotency-key и rate limit описываются аннотациями в OpenAPI/SQL.

Реализуемые паттерны:
- single-flight
- TTL + jitter
- кешируемые GET
- защищенные POST

Это исключает ручное написание middleware и пользовательской инфраструктуры.

---

## Наблюдаемость и диагностика

Встроено:
- OpenTelemetry-трейсы
- Prometheus-метрики (RPS, latency p50/p95/p99/p999, длины очередей, использование арен)
- структурные JSON-логи

Нагрузочные тесты, flamegraph и регрессия производительности включены в CI.  
Деградация задержек приводит к ошибке сборки.

---

## Dev-режим

Команда `katana dev` предоставляет:
- hot-reload модулей без перезапуска реакторов
- ускоренную сборку (clang + ccache)
- отключенный NUMA pinning
- автоматический запуск локальных PG / Redis / Prometheus / OpenTelemetry
- мок-репозитории

Цель — скорость итераций близкая к Node/FastAPI при сохранении архитектуры прод-исполнения.

---

## CLI

katana new # создание каркаса проекта
katana gen openapi # генерация маршрутов и DTO
katana gen sql # генерация моделей и репозиториев
katana dev # запуск в dev-режиме
katana db migrate # управление миграциями
katana bench # локальные нагрузочные тесты

---

## Границы применимости

Подходит для:
- API с высоким RPS
- систем, где важен контроль хвостовых задержек
- транзакционных систем и биллинга
- ML inference gateway
- real-time инфраструктурных сервисов

Не подходит для:
- простых CRUD и MVP без мониторинга
- команд, не готовых к работе с метриками и нагрузочным анализом

---

## Результат

- Предсказуемое время ответа.
- Контролируемый p99/p999.
- Нет глобальных очередей, гонок и GC.
- Нет ORM, но нет и бойлерплейта.
- Разработчик пишет логику, а не инфраструктуру.
